<!DOCTYPE html>
<html>
<head>
    <title>X-Plane REST API Demo with G3</title>
</head>
<body>
    <div id="panel"></div>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="g3-ws.js"></script>
<script type="text/javascript">
const WS_URL = "ws://192.168.1.140:8080/api/v2"

const METRICS = [
    {
        "metric": "engineRPM",
        "dref": "sim/cockpit2/engine/indicators/engine_speed_rpm[0]",
        "unit": "rpm"
    }
]


var g = g3.gauge()
    .metric("engineRPM").unit("rpm")
    .measure(d3.scaleLinear().domain([0,6000]).range([-125,125]))
    .css(`
text.g3-gauge-label, .g3-axis-labels text {
    font-stretch: normal;
    font-weight: 600;
    fill: #ccc;
}
.g3-gauge-face { fill: #282828 }
`)
    .append(
        g3.gaugeFace(),
        g3.gaugeFace().r(50).style("filter: url(#dropShadow2)"),
        g3.axisSector([5000,6000]).inset(50).size(35).style("fill: #800"),
        g3.gaugeLabel("SMITHS").y(-45).size(7),
        g3.gaugeLabel("8 CYL").y(40).size(7),
        // a trick to put a circular path label opposite the 3000RPM top of the gauge
        g3.put().rotate(180).append(
            g3.axisLabels({3000: "POSITIVE EARTH"}).orient("counterclockwise").size(3.5).inset(52)
        ),
        g3.gaugeLabel("RPM").y(65).size(12),
        g3.gaugeLabel("X 100").y(75).size(8),
        g3.gaugeScrew().shape("phillips").r(3).x(-20),
        g3.gaugeScrew().shape("phillips").r(3).x(20),
        g3.put().scale(0.95).append(
            g3.axisSector().style("fill: none; stroke: white"),
            g3.axisTicks().step(500).style("stroke-width: 5"),
            g3.axisTicks().step(100).size(5),
            g3.axisLabels().inset(20).size(15).format(v => v/100),
            g3.indicatePointer().append(
                // the full pointer blade
                g3.element("path", {d: "M 3,0 l -1.5,-90 l -1.5,-5 l -1.5,5 l -1.5,90 z"})
                    .style("fill: #ddd"),
                // the bottom half of the pointer, drawn over the full blade
                g3.element("path", {d: "M 3,0 l -0.75,-45 l -4.5,0 l -0.75,45 z"})
                    .style("fill: #333"),
                // a blurred highlight on the blade to give a bit of 3D effect
                g3.element("path", {d: "M -1,0 l 0,-90 l 2,0 z"})
                    .style("fill: white; filter: url(#gaussianBlur1); opacity: 0.5"),
                // the central hub, with a highlight
                g3.element("circle", {r: 15}).style("fill: #ccd"),
                g3.element("circle", {r: 15}).class("g3-highlight"),
                // the central pin
                g3.element("circle", {r: 5}).style("fill: #333"),
            ),
        ),
    );

var p = g3.panel()
    .width(640)
    .height(640)
    .interval(null)
    .url(WS_URL)
    .append(
        g3.put().x(320).y(320).scale(2).append(g)
    );

// this initialize the panel and creates the websocket
// we need the websocket in the next promise that resolves
// metric datarefs to dataref indices.
p("#panel");

// communicate dataref indices to panel
Promise.resolve(METRICS).then(metrics => { // build request to get dataref descriptions
    let datarefs = {}, reqbody = [];
    // structure of a dataref:
    // {
    //     "metric": "pitch",
    //     "dref": "sim/cockpit2/gauges/indicators/pitch_vacuum_deg_pilot",
    //     "unit": "deg",
    //     // added from X-Plane description:
    //     "index": 12345,
    //     "value_type": int, float, double, int_array, float_array, data, should probably be numeric value for metrics
    //     "writable": false, true,
    //     // we optionally keep the latest value
    //     "value": 0
    // }
    metrics.forEach(m => {
        m.path = m.dref
        if (m.dref.indexOf("[") >= 0 && m.dref.indexOf("]") >= 0) { // array
            m.array_index = parseInt(m.dref.substring(m.dref.indexOf("[")+1, m.dref.indexOf("]")));
            m.path = m.dref.substring(0, m.dref.indexOf("["));
            // console.log(m.dref, "is array", m.path, m.array_index);
        }
        reqbody.push(["filter[name]", m.path]);
        datarefs[m.path] = m;
    });
    return [reqbody, datarefs]
}).then(([reqdrefs, metric_datarefs]) => { // request descriptions
    const api_url = WS_URL.replace("ws:", "http:") + "/datarefs"
    let request = new Request(api_url + "?" + new URLSearchParams(reqdrefs).toString(), {
        headers: {
            "Content-Type": "application/json",
        }
    });
    return fetch(request)
    .then(r =>  r.json().then(result => { // store descriptions, access by dataref index
        // console.log("dataref info", result)
        let request_id = 1;
        let index_list = [];
        result.data.forEach(dataref => {
            if (["int", "float", "int_array", "float_array", "double"].indexOf(dataref.value_type) < 0) {
                console.log(d.name, "not a number type for metric", d.metric, dataref.value_type)
            }
            d = metric_datarefs[dataref.name]
            d.index = dataref.id;
            d.value_type = dataref.value_type;
            d.writable = dataref.is_writable;
            d.value = 0;
            index_list.push({"id": dataref.id}) // keep list of dataref index to request
        })
        p.ws().send(JSON.stringify({ // request dataref value updates
            "req_id": request_id,
            "type": "dataref_subscribe_values",
            "params": {
                "datarefs": index_list
            }
        }));
        console.log("sent", new Date(), {
            "req_id": request_id,
            "type": "dataref_subscribe_values",
            "params": {
                "datarefs": index_list
            }
        });
        // index by dataref index
        let didx = {};
        for (const [path, dataref] of Object.entries(metric_datarefs)) {
            didx[dataref.index] = dataref;
        }
        return didx;
    }))
}).then(r => {p.di(r);});

</script>
</body>
</html>